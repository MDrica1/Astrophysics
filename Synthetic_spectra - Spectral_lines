#!/usr/bin/env python2

#Accessing the library of synthetic spectra presented by Pickles in 1998, 
#fits files were downloaded containing the synthetic spectra of stars of types F5, G2, K5 and M0, and spectral class V.

import numpy as np
import matplotlib.pyplot as plt
from astropy import units as u
from astropy.analytic_functions import blackbody_lambda
import astropy.io.fits as pf
from astropy.table import Table
import math

espectros = ['J_PASP_110_863_f5v.dat.fits','J_PASP_110_863_g2v.dat.fits','J_PASP_110_863_k5v.dat.fits','J_PASP_110_863_m0v.dat.fits']

T=[6531.31,5636.38,4187.94,3801.89]

##The following function reads the header and data from the fits file and returns the wavelength range covered 
#by the synthetic spectrum, the flows for each wavelength and the flow error, in addition to printing the table containing the data. 

def lercabecalho(arq):

 hdu = pf.open(arq)
 head = hdu[1].header
 data = Table(hdu[1].data)
 lam = data['lambda']
 flux = data['nflam']
 err = data['sdnflam']
 flu = flux[np.where(flux != 0.0)]
 la=lam[np.where(flux!=0)]
 er=err[np.where(flux!=0)]
 print head
 print data
 return la,flu,er
 
#Here, a function was created that normalizes the spectra by the continuum, 
#that is, it generates a blackbody for a given temperature and divides the data flux by the blackbody flux.

def normaliza(lamb, fl,T):
 cn = 4*math.pi*((blackbody_lambda(lamb*u.AA,T*u.K))/(blackbody_lambda(5556*u.AA,T*u.K)))
 a=fl/cn
 bb = a[np.where(np.isnan(a)==False)]
 return bb

# It uses the previously created functions to perform the normalization and plot the normalized spectrum.
col=['navy','crimson','green','teal']
star=['F5 V','G2 V','K5 V','M0 V']
idt=['nF5v.png', 'nG2V.png','nK5V.png', 'nM0V.png']
for i in range(4):
 l,f,e = lercabecalho(espectros[i])
 fn = normaliza(l, f, T[i])
 y=np.ones(l.shape)
 plt.xlabel(u'Wavelength ($\AA$)')
 plt.ylabel(u'Fluxo Normalizado ($\mathrm{\\frac{F_{\lambda}}{F_{\lambda ,0}}}$)')
 plt.ylim(0,1.5)
 plt.plot(l,fn,lw=0.8,color=col[i])
 plt.hold('on')
 plt.plot(l,y,ls='--',color='grey')
 plt.title(star[i])
 #plt.text(' $T_{eff}=$'+str(T[i]))
 plt.legend(['Espectro normalizado pelo continuo','linha do continuo $\mathrm{\\frac{F_{\lambda}}{F_{\lambda ,0}}}=1$'])
 plt.savefig(idt[i])
 #plt.show()

#With the normalized data obtained through the normalization function, this new data is saved through the following function:

T=[6531.31,5636.38,4187.94,3801.89]
def salvaespecnormal(lam,flu,err,name,iesp):
 col1=pf.Column(name='Lambda', array=lam, format='K')
 col2=pf.Column(name='Fluxo', array=flu, format='D')
 col3=pf.Column(name='Erro do Fluxo', array=err, format='D')
 dados=pf.BinTableHDU.from_columns([col1,col2,col3])
 hdr=pf.Header()
 hdr['COMMENT']='O Espectro foi normalizado utilizando uma aproximacao de uma
curva de corpo negro para uma temperatura efetiva de '+str(T[iesp])+' K'
 coisa=pf.PrimaryHDU(header=hdr)
 lista=pf.HDUList([coisa,dados])
 lista.writeto('n_'+name, overwrite=True)
 
 #The following function generates the vectors used to plot the vertical lines that will indicate, 
 #in the graphs previously generated, the spectral lines worked on.
 
def plotespectrallines(a,b,c,d):
  yteste=np.arange(a,b,c)
  xteste=np.empty(yteste.shape)
  for i,n in enumerate(xteste):
    xteste[i]=lambdal[d]
  return xteste, yteste
